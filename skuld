#!/usr/bin/env python3
import argparse
import curses
import json
import os
import re
import shlex
import subprocess
import sys
import tempfile
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Dict, List, Optional

VERSION = "0.3.0"
NAME_RE = re.compile(r"^[a-zA-Z0-9][a-zA-Z0-9._@-]*$")
ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")
SHELL_SAFE_RE = re.compile(r"^[A-Za-z0-9_@%+=:,./-]+$")
SKULD_HOME = Path(os.environ.get("SKULD_HOME", Path.home() / ".local/share/skuld"))
REGISTRY_FILE = SKULD_HOME / "services.json"
DEFAULT_ENV_FILE = Path(".env")
USE_ENV_SUDO = True


@dataclass
class ManagedService:
    name: str
    exec_cmd: str
    description: str
    schedule: str = ""
    working_dir: str = ""
    user: str = ""
    restart: str = "on-failure"
    timer_persistent: bool = True
    id: int = 0


def ensure_storage() -> None:
    SKULD_HOME.mkdir(parents=True, exist_ok=True)
    if not REGISTRY_FILE.exists():
        REGISTRY_FILE.write_text("[]", encoding="utf-8")


def load_dotenv(path: Path) -> Dict[str, str]:
    if not path.exists():
        return {}
    env: Dict[str, str] = {}
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        env[k.strip()] = v.strip().strip('"').strip("'")
    return env


def get_sudo_password() -> Optional[str]:
    if not USE_ENV_SUDO:
        return None

    from_env = os.environ.get("SKULD_SUDO_PASSWORD")
    if from_env:
        return from_env

    env_path_override = os.environ.get("SKULD_ENV_FILE")
    candidate_files = []
    if env_path_override:
        candidate_files.append(Path(env_path_override))
    candidate_files.extend(
        [
            Path.cwd() / DEFAULT_ENV_FILE,
            Path(__file__).resolve().parent / DEFAULT_ENV_FILE,
            SKULD_HOME / ".env",
        ]
    )

    for env_path in candidate_files:
        if not env_path.exists():
            continue
        value = load_dotenv(env_path).get("SKULD_SUDO_PASSWORD")
        if value:
            return value
    return None


def load_registry() -> List[ManagedService]:
    ensure_storage()
    data = json.loads(REGISTRY_FILE.read_text(encoding="utf-8"))
    services = [ManagedService(**item) for item in data]
    changed = False
    used_ids = set()
    next_id = 1
    for svc in services:
        if svc.id <= 0 or svc.id in used_ids:
            while next_id in used_ids:
                next_id += 1
            svc.id = next_id
            changed = True
        used_ids.add(svc.id)
    if changed:
        save_registry(services)
    return services


def save_registry(services: List[ManagedService]) -> None:
    ensure_storage()
    REGISTRY_FILE.write_text(
        json.dumps([asdict(s) for s in services], indent=2, ensure_ascii=False),
        encoding="utf-8",
    )


def upsert_registry(service: ManagedService) -> None:
    services = load_registry()
    by_name = {s.name: s for s in services}
    existing = by_name.get(service.name)
    if service.id <= 0 and existing:
        service.id = existing.id
    if service.id <= 0:
        max_id = max((s.id for s in services), default=0)
        service.id = max_id + 1
    by_name[service.name] = service
    save_registry(sorted(by_name.values(), key=lambda s: s.name.lower()))


def remove_registry(name: str) -> None:
    services = [s for s in load_registry() if s.name != name]
    save_registry(services)


def get_managed(name: str) -> Optional[ManagedService]:
    for svc in load_registry():
        if svc.name == name:
            return svc
    return None


def get_managed_by_id(service_id: int) -> Optional[ManagedService]:
    for svc in load_registry():
        if svc.id == service_id:
            return svc
    return None


def require_managed(name: str) -> ManagedService:
    svc = get_managed(name)
    if not svc:
        raise RuntimeError(
            f"'{name}' is not in the skuld registry. "
            "Only services created or adopted via skuld can be monitored."
        )
    return svc


def err(msg: str) -> None:
    print(f"[error] {msg}", file=sys.stderr)


def info(msg: str) -> None:
    print(f"[skuld] {msg}")


def ok(msg: str) -> None:
    print(f"[ok] {msg}")


def is_tty() -> bool:
    return sys.stdout.isatty()


def colorize(text: str, color: str) -> str:
    if not is_tty():
        return text
    palette = {
        "green": "\033[32m",
        "red": "\033[31m",
        "yellow": "\033[33m",
        "cyan": "\033[36m",
        "gray": "\033[90m",
        "reset": "\033[0m",
    }
    return f"{palette.get(color, '')}{text}{palette['reset']}"


def visible_len(text: str) -> int:
    return len(ANSI_RE.sub("", text))


def validate_name(name: str) -> None:
    if not NAME_RE.match(name):
        raise ValueError("Invalid name. Use [a-zA-Z0-9._@-] and start with a letter/number.")


def resolve_name_arg(args: argparse.Namespace, required: bool = True) -> Optional[str]:
    positional = getattr(args, "name", None)
    flag_value = getattr(args, "name_flag", None)
    if positional and flag_value and positional != flag_value:
        raise RuntimeError(f"Conflicting names provided: positional='{positional}' and --name='{flag_value}'.")
    name = flag_value or positional
    if required and not name:
        raise RuntimeError("Service name is required. Use NAME or --name NAME.")
    return name


def resolve_managed_from_token(token: str) -> Optional[ManagedService]:
    svc = get_managed(token)
    if svc:
        return svc
    if token.isdigit():
        return get_managed_by_id(int(token))
    return None


def resolve_managed_arg(args: argparse.Namespace, required: bool = True) -> Optional[ManagedService]:
    positional = getattr(args, "name", None)
    name_flag = getattr(args, "name_flag", None)
    id_flag = getattr(args, "id_flag", None)

    if positional and name_flag and positional != name_flag:
        raise RuntimeError(
            f"Conflicting targets provided: positional='{positional}' and --name='{name_flag}'."
        )

    token = name_flag or positional
    by_token = None
    if token:
        by_token = resolve_managed_from_token(token)
        if not by_token:
            raise RuntimeError(f"Managed service '{token}' not found (name or id).")

    by_id = None
    if id_flag is not None:
        by_id = get_managed_by_id(id_flag)
        if not by_id:
            raise RuntimeError(f"Managed service id '{id_flag}' not found.")

    if by_token and by_id and by_token.id != by_id.id:
        raise RuntimeError(
            f"Conflicting targets provided: '{token}' resolves to id={by_token.id}, "
            f"but --id={id_flag}."
        )

    svc = by_id or by_token
    if required and not svc:
        raise RuntimeError("Service target is required. Use NAME/ID, --name NAME, or --id ID.")
    return svc


def resolve_managed_many_arg(args: argparse.Namespace) -> List[ManagedService]:
    positional_tokens = getattr(args, "targets", None) or []
    name_flag = getattr(args, "name_flag", None)
    id_flag = getattr(args, "id_flag", None)

    tokens: List[str] = list(positional_tokens)
    if name_flag:
        tokens.append(name_flag)
    if id_flag is not None:
        tokens.append(str(id_flag))

    if not tokens:
        raise RuntimeError("At least one service target is required. Use NAME/ID, --name NAME, or --id ID.")

    resolved: List[ManagedService] = []
    seen_ids = set()
    for token in tokens:
        svc = resolve_managed_from_token(token)
        if not svc:
            raise RuntimeError(f"Managed service '{token}' not found (name or id).")
        if svc.id in seen_ids:
            continue
        seen_ids.add(svc.id)
        resolved.append(svc)
    return resolved


def resolve_lines_arg(args: argparse.Namespace, default: int = 100) -> int:
    lines_flag = getattr(args, "lines", None)
    lines_pos = getattr(args, "lines_pos", None)
    if lines_flag is not None:
        return lines_flag
    if lines_pos is not None:
        return lines_pos
    return default


def run(cmd: List[str], check: bool = True, capture: bool = False, input_text: Optional[str] = None) -> subprocess.CompletedProcess:
    kwargs = {"text": True}
    if capture:
        kwargs["capture_output"] = True
    if input_text is not None:
        kwargs["input"] = input_text
    proc = subprocess.run(cmd, **kwargs)
    if check and proc.returncode != 0:
        raise RuntimeError(f"Command failed: {' '.join(shlex.quote(c) for c in cmd)}")
    return proc


def run_sudo(cmd: List[str], check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    pwd = get_sudo_password()
    full = ["sudo"] + cmd
    if pwd:
        full = ["sudo", "-S", "-k", "-p", ""] + cmd
        return run(full, check=check, capture=capture, input_text=pwd + "\n")
    return run(full, check=check, capture=capture)


def require_systemctl() -> None:
    try:
        run(["systemctl", "--version"], check=True, capture=True)
    except Exception as exc:
        raise RuntimeError("systemctl not found. This tool requires Linux with systemd.") from exc


def unit_exists(unit: str) -> bool:
    proc = run(["systemctl", "list-unit-files", "--no-legend", unit], check=False, capture=True)
    out = (proc.stdout or "").strip()
    return bool(out and unit in out)


def unit_active(unit: str) -> str:
    proc = run(["systemctl", "is-active", unit], check=False, capture=True)
    status = (proc.stdout or "").strip()
    return status if status else "inactive"


def format_bytes(value: str) -> str:
    raw = (value or "").strip()
    if not raw or raw in ("[not set]", "n/a"):
        return "-"
    try:
        num = int(raw)
    except ValueError:
        return "-"
    if num < 0:
        return "-"
    units = ["B", "KB", "MB", "GB", "TB"]
    size = float(num)
    idx = 0
    while size >= 1024 and idx < len(units) - 1:
        size /= 1024.0
        idx += 1
    if idx == 0:
        return f"{int(size)}{units[idx]}"
    return f"{size:.1f}{units[idx]}"


def format_cpu_nsec(value: str) -> str:
    raw = (value or "").strip()
    if not raw or raw in ("[not set]", "n/a"):
        return "-"
    try:
        nsec = int(raw)
    except ValueError:
        return "-"
    if nsec < 0:
        return "-"
    seconds = nsec / 1_000_000_000
    if seconds < 1:
        return f"{seconds * 1000:.0f}ms"
    if seconds < 60:
        return f"{seconds:.1f}s"
    minutes = int(seconds // 60)
    rem = seconds - (minutes * 60)
    if minutes < 60:
        return f"{minutes}m{rem:.0f}s"
    hours = int(minutes // 60)
    rem_min = minutes % 60
    return f"{hours}h{rem_min}m"


def parse_int(value: str) -> int:
    try:
        num = int((value or "").strip())
    except ValueError:
        return 0
    return num if num > 0 else 0


def format_gpu_mib(value: int) -> str:
    if value <= 0:
        return "0MB"
    if value < 1024:
        return f"{value}MB"
    gib = value / 1024
    text = f"{gib:.1f}".rstrip("0").rstrip(".")
    return f"{text}GB"


def read_gpu_memory_by_pid() -> Optional[Dict[int, int]]:
    cmd = [
        "nvidia-smi",
        "--query-compute-apps=pid,used_gpu_memory",
        "--format=csv,noheader,nounits",
    ]
    try:
        proc = run(cmd, check=False, capture=True)
    except FileNotFoundError:
        return None
    if proc.returncode != 0:
        return None

    by_pid: Dict[int, int] = {}
    output = (proc.stdout or "").strip()
    if not output:
        return by_pid

    for line in output.splitlines():
        parts = [p.strip() for p in line.split(",", 1)]
        if len(parts) != 2:
            continue
        pid = parse_int(parts[0])
        if pid <= 0:
            continue
        try:
            used_mib = int(parts[1])
        except ValueError:
            continue
        if used_mib < 0:
            continue
        by_pid[pid] = by_pid.get(pid, 0) + used_mib
    return by_pid


def read_unit_usage(name: str, gpu_memory_by_pid: Optional[Dict[int, int]] = None) -> Dict[str, str]:
    service_unit = f"{name}.service"
    if not unit_exists(service_unit):
        return {"cpu": "-", "memory": "-", "gpu": "-"}
    show = systemctl_show(service_unit, ["CPUUsageNSec", "MemoryCurrent", "MainPID"])
    pid = parse_int(show.get("MainPID", ""))
    gpu_usage = "-"
    if gpu_memory_by_pid is not None:
        gpu_usage = format_gpu_mib(gpu_memory_by_pid.get(pid, 0) if pid > 0 else 0)
    return {
        "cpu": format_cpu_nsec(show.get("CPUUsageNSec", "")),
        "memory": format_bytes(show.get("MemoryCurrent", "")),
        "gpu": gpu_usage,
    }


def get_main_pid(name: str) -> int:
    unit = f"{name}.service"
    if not unit_exists(unit):
        return 0
    show = systemctl_show(unit, ["MainPID"])
    return parse_int(show.get("MainPID", ""))


def parse_listen_ports_from_ss(output: str, pid: int) -> List[str]:
    ports: List[str] = []
    seen = set()
    marker = f"pid={pid},"
    for line in output.splitlines():
        if marker not in line:
            continue
        parts = line.split()
        if len(parts) < 6:
            continue
        local = parts[4]
        proto = parts[0].lower()
        if proto not in ("tcp", "tcp6", "udp", "udp6"):
            continue
        port = ""
        if "[" in local and "]:" in local:
            # [::]:8000
            port = local.rsplit("]:", 1)[-1]
        elif ":" in local:
            # 0.0.0.0:8000 or *:53
            port = local.rsplit(":", 1)[-1]
        if not port or not port.isdigit():
            continue
        proto_tag = "tcp" if "tcp" in proto else "udp"
        tag = f"{port}/{proto_tag}"
        if tag not in seen:
            seen.add(tag)
            ports.append(tag)
    return sorted(ports)


def summarize_ports(ports: List[str], max_items: int = 2) -> str:
    if not ports:
        return "-"
    if len(ports) <= max_items:
        return ",".join(ports)
    shown = ",".join(ports[:max_items])
    return f"{shown}+{len(ports) - max_items}"


def read_unit_ports(name: str) -> str:
    pid = get_main_pid(name)
    if pid <= 0:
        return "-"

    cmd = ["ss", "-ltnup"]
    proc = run(cmd, check=False, capture=True)
    output = (proc.stdout or "")
    ports = parse_listen_ports_from_ss(output, pid)

    # Some systems omit process ownership details without sudo but do not emit
    # an explicit permission error. If no port is detected for a live PID,
    # retry with sudo.
    needs_sudo = not ports
    if needs_sudo:
        proc = run_sudo(cmd, check=False, capture=True)
        output = (proc.stdout or "")
        ports = parse_listen_ports_from_ss(output, pid)

    return summarize_ports(ports)


def render_table(headers: List[str], rows: List[List[str]]) -> None:
    if not rows:
        return
    widths = [visible_len(h) for h in headers]
    for row in rows:
        for i, cell in enumerate(row):
            widths[i] = max(widths[i], visible_len(cell))

    def hline(ch: str = "-") -> str:
        return "+" + "+".join(ch * (w + 2) for w in widths) + "+"

    def format_row(cells: List[str]) -> str:
        padded = []
        for i, cell in enumerate(cells):
            pad = widths[i] - visible_len(cell)
            padded.append(f" {cell}{' ' * max(0, pad)} ")
        return "|" + "|".join(padded) + "|"

    print(hline("-"))
    print(format_row(headers))
    print(hline("="))
    for row in rows:
        print(format_row(row))
    print(hline("-"))


def clip_text(text: str, width: int) -> str:
    if width <= 0:
        return ""
    if len(text) <= width:
        return text
    if width <= 3:
        return text[:width]
    return text[: width - 3] + "..."


def shell_quote_pretty(value: str) -> str:
    if value == "":
        return '""'
    if SHELL_SAFE_RE.match(value):
        return value
    escaped = (
        value.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("$", "\\$")
        .replace("`", "\\`")
    )
    escaped = escaped.replace("\n", "\\n")
    return f'"{escaped}"'


def read_timer_schedule(name: str) -> str:
    timer_unit = f"{name}.timer"
    if not unit_exists(timer_unit):
        return ""
    show = systemctl_show(timer_unit, ["OnCalendar"])
    schedule = (show.get("OnCalendar", "") or "").strip()
    if schedule:
        return schedule
    directives = parse_unit_directives(systemctl_cat(timer_unit))
    return (directives.get("OnCalendar", "") or "").strip()


def read_timer_persistent(name: str, default: bool = True) -> bool:
    timer_unit = f"{name}.timer"
    if not unit_exists(timer_unit):
        return default
    show = systemctl_show(timer_unit, ["Persistent"])
    value = (show.get("Persistent", "") or "").strip()
    if value:
        return parse_bool(value, default=default)
    directives = parse_unit_directives(systemctl_cat(timer_unit))
    raw = (directives.get("Persistent", "") or "").strip()
    if raw:
        return parse_bool(raw, default=default)
    return default


def schedule_for_display(svc: ManagedService) -> str:
    if svc.schedule:
        return svc.schedule
    return read_timer_schedule(svc.name)


def sync_registry_from_systemd(name: Optional[str] = None) -> int:
    services = load_registry()
    changed = 0
    target_names = {name} if name else None
    updated: List[ManagedService] = []

    for svc in services:
        if target_names and svc.name not in target_names:
            updated.append(svc)
            continue

        new_svc = ManagedService(**asdict(svc))
        svc_unit = f"{svc.name}.service"
        timer_unit = f"{svc.name}.timer"

        if unit_exists(svc_unit):
            show_svc = systemctl_show(svc_unit, ["Description", "WorkingDirectory", "User", "Restart"])
            if not new_svc.description and show_svc.get("Description"):
                new_svc.description = show_svc["Description"]
            if not new_svc.working_dir and show_svc.get("WorkingDirectory"):
                new_svc.working_dir = show_svc["WorkingDirectory"]
            if not new_svc.user and show_svc.get("User"):
                new_svc.user = show_svc["User"]
            if (not new_svc.restart or new_svc.restart == "on-failure") and show_svc.get("Restart"):
                new_svc.restart = show_svc["Restart"]

        if unit_exists(timer_unit):
            if not new_svc.schedule:
                new_svc.schedule = read_timer_schedule(svc.name)
            new_svc.timer_persistent = read_timer_persistent(svc.name, default=new_svc.timer_persistent)

        if asdict(new_svc) != asdict(svc):
            changed += 1
            updated.append(new_svc)
        else:
            updated.append(svc)

    if changed:
        save_registry(updated)
    return changed


def systemctl_show(unit: str, props: List[str]) -> Dict[str, str]:
    cmd = ["systemctl", "show", unit, "--no-pager"]
    for p in props:
        cmd.extend(["-p", p])
    proc = run(cmd, check=False, capture=True)
    result: Dict[str, str] = {}
    for line in (proc.stdout or "").splitlines():
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        result[k] = v
    return result


def systemctl_cat(unit: str) -> str:
    proc = run(["systemctl", "cat", unit, "--no-pager"], check=False, capture=True)
    if proc.returncode != 0:
        return ""
    return proc.stdout or ""


def parse_unit_directives(unit_text: str) -> Dict[str, str]:
    directives: Dict[str, str] = {}
    for raw in unit_text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        k, v = line.split("=", 1)
        directives[k] = v
    return directives


def parse_bool(value: str, default: bool = True) -> bool:
    if value is None:
        return default
    v = value.strip().lower()
    if v in ("1", "true", "yes", "on"):
        return True
    if v in ("0", "false", "no", "off"):
        return False
    return default


def write_systemd_file(target: str, content: str) -> None:
    with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tf:
        tf.write(content)
        tmp_path = tf.name
    try:
        run_sudo(["cp", tmp_path, target])
    finally:
        Path(tmp_path).unlink(missing_ok=True)


def render_service(name: str, description: str, exec_cmd: str, working_dir: str, user: str, restart: str) -> str:
    wd_line = f"WorkingDirectory={working_dir}\n" if working_dir else ""
    user_line = f"User={user}\n" if user else ""
    return (
        "[Unit]\n"
        f"Description={description}\n"
        "After=network.target\n\n"
        "[Service]\n"
        "Type=simple\n"
        f"ExecStart=/bin/bash -lc {shlex.quote(exec_cmd)}\n"
        f"Restart={restart}\n"
        f"{user_line}{wd_line}"
        "\n"
        "[Install]\n"
        "WantedBy=multi-user.target\n"
    )


def render_timer(name: str, schedule: str, persistent: bool) -> str:
    p = "true" if persistent else "false"
    return (
        "[Unit]\n"
        f"Description=Timer for {name}.service\n\n"
        "[Timer]\n"
        f"OnCalendar={schedule}\n"
        f"Persistent={p}\n"
        f"Unit={name}.service\n\n"
        "[Install]\n"
        "WantedBy=timers.target\n"
    )


def create(args: argparse.Namespace) -> None:
    require_systemctl()
    validate_name(args.name)

    desc = args.description or f"Skuld service: {args.name}"
    service_content = render_service(
        name=args.name,
        description=desc,
        exec_cmd=args.exec,
        working_dir=args.working_dir or "",
        user=args.user or "",
        restart=args.restart,
    )
    service_file = f"/etc/systemd/system/{args.name}.service"

    info(f"Creating {service_file}")
    write_systemd_file(service_file, service_content)

    if args.schedule:
        timer_content = render_timer(args.name, args.schedule, args.timer_persistent)
        timer_file = f"/etc/systemd/system/{args.name}.timer"
        info(f"Creating {timer_file}")
        write_systemd_file(timer_file, timer_content)

    run_sudo(["systemctl", "daemon-reload"])
    run_sudo(["systemctl", "enable", f"{args.name}.service"])

    if args.schedule:
        run_sudo(["systemctl", "enable", "--now", f"{args.name}.timer"])

    upsert_registry(
        ManagedService(
            name=args.name,
            exec_cmd=args.exec,
            description=desc,
            schedule=args.schedule or "",
            working_dir=args.working_dir or "",
            user=args.user or "",
            restart=args.restart,
            timer_persistent=args.timer_persistent,
        )
    )
    ok(f"Service '{args.name}' created and registered.")


def list_services(_args: argparse.Namespace) -> None:
    require_systemctl()
    sync_registry_from_systemd()
    services = sorted(load_registry(), key=lambda s: s.name.lower())
    if not services:
        print("No services managed by skuld.")
        return

    rows: List[List[str]] = []
    gpu_memory_by_pid = read_gpu_memory_by_pid()
    print()
    for svc in services:
        s_unit = f"{svc.name}.service"
        t_unit = f"{svc.name}.timer"
        s_state_raw = unit_active(s_unit) if unit_exists(s_unit) else "missing"
        t_state_raw = unit_active(t_unit) if unit_exists(t_unit) else "n/a"
        schedule = schedule_for_display(svc) or "-"
        usage = read_unit_usage(svc.name, gpu_memory_by_pid)
        kind = "timer" if schedule != "-" else "daemon"
        if s_state_raw == "active":
            s_state = colorize("active", "green")
        elif s_state_raw == "inactive":
            s_state = colorize("inactive", "yellow")
        else:
            s_state = colorize(s_state_raw, "red")
        if t_state_raw == "active":
            t_state = colorize("active", "green")
        elif t_state_raw == "inactive":
            t_state = colorize("inactive", "yellow")
        elif t_state_raw == "n/a":
            t_state = colorize("n/a", "gray")
        else:
            t_state = colorize(t_state_raw, "red")
        rows.append(
            [
                str(svc.id),
                svc.name,
                kind,
                s_state,
                t_state,
                schedule,
                usage["cpu"],
                usage["memory"],
                usage["gpu"],
                read_unit_ports(svc.name),
            ]
        )
    render_table(
        ["id", "name", "kind", "service", "timer", "schedule", "cpu", "memory", "gpu", "ports"],
        rows,
    )
    print()


def exec_now(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args)
    name = svc.name
    require_systemctl()
    run_sudo(["systemctl", "start", f"{name}.service"])
    ok(f"Execution started: {name}.service")


def managed_uses_timer(svc: ManagedService) -> bool:
    return bool(svc.schedule) or unit_exists(f"{svc.name}.timer")


def apply_action_for_managed(svc: ManagedService, action: str) -> None:
    name = svc.name
    service_unit = f"{name}.service"
    timer_unit = f"{name}.timer"
    uses_timer = managed_uses_timer(svc)

    if uses_timer:
        run_sudo(["systemctl", action, timer_unit], check=False)
        ok(f"{action} -> {timer_unit}")
        return

    run_sudo(["systemctl", action, service_unit], check=False)
    ok(f"{action} -> {service_unit}")


def start_stop(args: argparse.Namespace, action: str) -> None:
    services = resolve_managed_many_arg(args)
    require_systemctl()
    for svc in services:
        apply_action_for_managed(svc, action)


def restart(args: argparse.Namespace) -> None:
    start_stop(args, "restart")


def status(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args)
    name = svc.name
    require_systemctl()
    run(["systemctl", "status", f"{name}.service", "--no-pager"], check=False)
    run(["systemctl", "status", f"{name}.timer", "--no-pager"], check=False)


def logs(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args)
    name = svc.name
    lines = resolve_lines_arg(args, default=100)
    require_systemctl()
    unit = f"{name}.timer" if args.timer else f"{name}.service"
    cmd = ["journalctl", "-u", unit, "-n", str(lines)]
    output_mode = "cat" if args.plain else args.output
    cmd.extend(["-o", output_mode])
    if args.since:
        cmd.extend(["--since", args.since])
    if args.follow:
        cmd.append("-f")
        # For streaming mode, avoid capture so output is shown in real time.
        probe_cmd = [c for c in cmd if c != "-f"] + ["-n", "1", "--no-pager"]
        probe = run(probe_cmd, check=False, capture=True)
        probe_err = (probe.stderr or "").lower()
        needs_sudo = (
            "not seeing messages from other users and the system" in probe_err
            or "permission denied" in probe_err
        )
        if needs_sudo:
            run_sudo(cmd, check=False)
        else:
            run(cmd, check=False)
        return
    else:
        cmd.append("--no-pager")
    proc = run(cmd, check=False, capture=True)
    stderr = (proc.stderr or "").strip()
    stdout = (proc.stdout or "").strip()

    permission_hint = (
        "not seeing messages from other users and the system" in stderr.lower()
        or "permission denied" in stderr.lower()
    )
    if permission_hint:
        proc = run_sudo(cmd, check=False, capture=True)
        stderr = (proc.stderr or "").strip()
        stdout = (proc.stdout or "").strip()

    if stdout:
        print(stdout)
    if stderr:
        print(stderr, file=sys.stderr)


def recreate(args: argparse.Namespace) -> None:
    target = resolve_managed_arg(args)
    name = target.name
    sync_registry_from_systemd(name)
    svc = require_managed(name)
    print(build_recreate_command(svc))


def build_recreate_command(svc: ManagedService) -> str:
    lines = [
        "skuld create \\",
        f"  --name {shell_quote_pretty(svc.name)} \\",
        f"  --description {shell_quote_pretty(svc.description)} \\",
    ]
    if svc.working_dir:
        lines.append(f"  --working-dir {shell_quote_pretty(svc.working_dir)} \\")
    if svc.user:
        lines.append(f"  --user {shell_quote_pretty(svc.user)} \\")
    lines.append(f"  --restart {shell_quote_pretty(svc.restart)} \\")
    lines.append(f"  --exec {shell_quote_pretty(svc.exec_cmd)}")
    if svc.schedule:
        lines[-1] = lines[-1] + " \\"
        lines.append(f"  --schedule {shell_quote_pretty(svc.schedule)} \\")
        lines.append("  --timer-persistent" if svc.timer_persistent else "  --no-timer-persistent")
    return "\n".join(lines)


def remove(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args)
    name = svc.name
    require_systemctl()

    service_unit = f"{name}.service"
    timer_unit = f"{name}.timer"

    # Stop first to avoid lingering runtime when removing daemon units.
    run_sudo(["systemctl", "stop", timer_unit], check=False)
    run_sudo(["systemctl", "stop", service_unit], check=False)

    # If still active for any reason (restart policies/races), force kill.
    if unit_active(service_unit) == "active":
        run_sudo(["systemctl", "kill", service_unit], check=False)
        run_sudo(["systemctl", "stop", service_unit], check=False)

    run_sudo(["systemctl", "disable", timer_unit], check=False)
    run_sudo(["systemctl", "disable", service_unit], check=False)
    run_sudo(["rm", "-f", f"/etc/systemd/system/{name}.service"])
    run_sudo(["rm", "-f", f"/etc/systemd/system/{name}.timer"])
    run_sudo(["systemctl", "daemon-reload"])
    run_sudo(["systemctl", "reset-failed", service_unit], check=False)
    run_sudo(["systemctl", "reset-failed", timer_unit], check=False)

    if args.purge:
        remove_registry(name)
    ok(f"Removed: {name} (purge={args.purge})")


def adopt(args: argparse.Namespace) -> None:
    name = resolve_name_arg(args)
    require_systemctl()
    validate_name(name)
    if get_managed(name):
        raise RuntimeError(f"'{name}' is already registered in skuld.")

    service_unit = f"{name}.service"
    timer_unit = f"{name}.timer"
    if not unit_exists(service_unit):
        raise RuntimeError(f"Service '{service_unit}' does not exist in systemd.")

    service_text = systemctl_cat(service_unit)
    directives = parse_unit_directives(service_text)
    exec_line = directives.get("ExecStart", "")
    if exec_line.startswith("/bin/bash -lc "):
        exec_line = exec_line[len("/bin/bash -lc "):].strip()
        if len(exec_line) >= 2 and exec_line[0] == exec_line[-1] and exec_line[0] in ("'", '"'):
            exec_line = exec_line[1:-1]
    if not exec_line:
        raise RuntimeError("Could not infer ExecStart for adopt.")

    show_service = systemctl_show(service_unit, ["Description", "WorkingDirectory", "User", "Restart"])
    schedule = ""
    timer_persistent = True
    if unit_exists(timer_unit):
        show_timer = systemctl_show(timer_unit, ["OnCalendar", "Persistent"])
        schedule = show_timer.get("OnCalendar", "") or ""
        timer_persistent = parse_bool(show_timer.get("Persistent", "true"), default=True)

    upsert_registry(
        ManagedService(
            name=name,
            exec_cmd=exec_line,
            description=show_service.get("Description", f"Skuld service: {name}"),
            schedule=schedule,
            working_dir=show_service.get("WorkingDirectory", "") or "",
            user=show_service.get("User", "") or "",
            restart=show_service.get("Restart", "on-failure") or "on-failure",
            timer_persistent=timer_persistent,
        )
    )
    ok(f"Service '{name}' adopted into the skuld registry.")


def doctor(_args: argparse.Namespace) -> None:
    require_systemctl()
    sync_registry_from_systemd()
    services = load_registry()
    if not services:
        print("No services managed by skuld.")
        return

    issues = 0
    for svc in services:
        service_unit = f"{svc.name}.service"
        timer_unit = f"{svc.name}.timer"
        line_prefix = f"[{svc.name}]"

        if not unit_exists(service_unit):
            print(f"{line_prefix} ERROR missing service unit ({service_unit})")
            issues += 1
        else:
            st = unit_active(service_unit)
            print(f"{line_prefix} service={st}")

        has_timer = bool(svc.schedule)
        runtime_schedule = read_timer_schedule(svc.name)
        if not has_timer and runtime_schedule:
            print(
                f"{line_prefix} WARN registry schedule is empty, "
                f"but timer OnCalendar is '{runtime_schedule}'"
            )
            issues += 1
        if has_timer and not unit_exists(timer_unit):
            print(f"{line_prefix} ERROR expected timer is missing ({timer_unit})")
            issues += 1
        if (not has_timer) and unit_exists(timer_unit):
            print(f"{line_prefix} WARN timer exists, but registry has no schedule")
            issues += 1

        if unit_exists(service_unit):
            cat = parse_unit_directives(systemctl_cat(service_unit))
            current_exec = cat.get("ExecStart", "")
            if svc.exec_cmd and svc.exec_cmd not in current_exec:
                print(f"{line_prefix} WARN ExecStart differs from registry")
                issues += 1

    if issues == 0:
        ok("doctor: no issues found.")
    else:
        err(f"doctor: found {issues} issue(s).")


def apply_managed_update(
    current: ManagedService,
    *,
    exec_cmd: Optional[str] = None,
    description: Optional[str] = None,
    working_dir: Optional[str] = None,
    user: Optional[str] = None,
    restart: Optional[str] = None,
    schedule: Optional[str] = None,
    timer_persistent: Optional[bool] = None,
    clear_schedule: bool = False,
) -> bool:
    name = current.name
    new_exec = exec_cmd if exec_cmd is not None else current.exec_cmd
    new_description = description if description is not None else current.description
    new_workdir = working_dir if working_dir is not None else current.working_dir
    new_user = user if user is not None else current.user
    new_restart = restart if restart is not None else current.restart
    new_schedule = schedule if schedule is not None else current.schedule
    if clear_schedule:
        new_schedule = ""
    new_timer_persistent = current.timer_persistent if timer_persistent is None else timer_persistent

    if (
        new_exec == current.exec_cmd
        and new_description == current.description
        and new_workdir == current.working_dir
        and new_user == current.user
        and new_restart == current.restart
        and new_schedule == current.schedule
        and new_timer_persistent == current.timer_persistent
    ):
        return False

    service_content = render_service(
        name=name,
        description=new_description,
        exec_cmd=new_exec,
        working_dir=new_workdir,
        user=new_user,
        restart=new_restart,
    )
    write_systemd_file(f"/etc/systemd/system/{name}.service", service_content)

    timer_path = f"/etc/systemd/system/{name}.timer"
    if new_schedule:
        timer_content = render_timer(name, new_schedule, new_timer_persistent)
        write_systemd_file(timer_path, timer_content)
    else:
        run_sudo(["rm", "-f", timer_path], check=False)

    run_sudo(["systemctl", "daemon-reload"])
    run_sudo(["systemctl", "enable", f"{name}.service"], check=False)
    if new_schedule:
        run_sudo(["systemctl", "enable", f"{name}.timer"], check=False)

    upsert_registry(
        ManagedService(
            name=name,
            exec_cmd=new_exec,
            description=new_description,
            schedule=new_schedule,
            working_dir=new_workdir,
            user=new_user,
            restart=new_restart,
            timer_persistent=new_timer_persistent,
            id=current.id,
        )
    )
    return True


def edit(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args)
    name = svc.name
    require_systemctl()
    current = require_managed(name)

    changed = apply_managed_update(
        current,
        exec_cmd=args.exec,
        description=args.description,
        working_dir=args.working_dir,
        user=args.user,
        restart=args.restart,
        schedule=args.schedule,
        timer_persistent=args.timer_persistent,
        clear_schedule=args.clear_schedule,
    )
    if not changed:
        info("No changes detected.")
        return
    ok(f"Service '{name}' updated.")


def describe(args: argparse.Namespace) -> None:
    target = resolve_managed_arg(args)
    name = target.name
    require_systemctl()
    sync_registry_from_systemd(name)
    svc = require_managed(name)
    service_unit = f"{name}.service"
    timer_unit = f"{name}.timer"

    show_service = systemctl_show(
        service_unit,
        ["Id", "Description", "ActiveState", "SubState", "FragmentPath", "MainPID"],
    )
    show_timer = systemctl_show(
        timer_unit,
        ["Id", "ActiveState", "SubState", "NextElapseUSecRealtime", "LastTriggerUSec"],
    ) if unit_exists(timer_unit) else {}

    print(f"name: {svc.name}")
    print(f"description: {svc.description}")
    print(f"exec: {svc.exec_cmd}")
    print(f"working_dir: {svc.working_dir or '-'}")
    print(f"user: {svc.user or '-'}")
    print(f"restart: {svc.restart}")
    print(f"schedule: {svc.schedule or '-'}")
    print(f"timer_persistent: {svc.timer_persistent}")
    print("---")
    print(f"service_active: {show_service.get('ActiveState', 'unknown')}")
    print(f"service_substate: {show_service.get('SubState', 'unknown')}")
    print(f"main_pid: {show_service.get('MainPID', '-')}")
    print(f"fragment: {show_service.get('FragmentPath', '-')}")
    if show_timer:
        print(f"timer_active: {show_timer.get('ActiveState', 'unknown')}")
        print(f"timer_substate: {show_timer.get('SubState', 'unknown')}")
        print(f"next_run: {show_timer.get('NextElapseUSecRealtime', '-')}")
        print(f"last_trigger: {show_timer.get('LastTriggerUSec', '-')}")
    else:
        print("timer: n/a")


def tui_loop(stdscr: "curses._CursesWindow") -> None:
    curses.use_default_colors()
    curses.curs_set(0)
    stdscr.nodelay(False)
    stdscr.keypad(True)
    idx = 0
    message = "q quit | Enter details | e exec | s start | t stop | R restart | d describe"

    c_header = 0
    c_active = 0
    c_inactive = 0
    c_missing = 0
    c_na = 0
    if curses.has_colors():
        curses.start_color()
        curses.init_pair(1, curses.COLOR_CYAN, -1)
        curses.init_pair(2, curses.COLOR_GREEN, -1)
        curses.init_pair(3, curses.COLOR_YELLOW, -1)
        curses.init_pair(4, curses.COLOR_RED, -1)
        curses.init_pair(5, curses.COLOR_BLACK, -1)
        c_header = curses.color_pair(1)
        c_active = curses.color_pair(2)
        c_inactive = curses.color_pair(3)
        c_missing = curses.color_pair(4)
        c_na = curses.color_pair(5)

    columns = [
        ("ID", 4),
        ("Name", 20),
        ("Kind", 8),
        ("Service", 10),
        ("Timer", 8),
        ("Schedule", 18),
        ("CPU", 9),
        ("Memory", 9),
        ("GPU", 8),
        ("Ports", 14),
    ]

    def hline() -> str:
        return "+" + "+".join("-" * (w + 2) for _, w in columns) + "+"

    def row_line(values: List[str]) -> str:
        cells = []
        for i, (_, width) in enumerate(columns):
            value = values[i] if i < len(values) else ""
            cells.append(f" {clip_text(value, width).ljust(width)} ")
        return "|" + "|".join(cells) + "|"

    def prompt_input(prompt: str) -> Optional[str]:
        h, w = stdscr.getmaxyx()
        y = max(0, h - 2)
        stdscr.move(y, 0)
        stdscr.clrtoeol()
        label = f"{prompt} "
        stdscr.addstr(y, 0, clip_text(label, max(0, w - 1)))
        x = min(len(label), max(0, w - 2))
        stdscr.move(y, x)
        curses.echo()
        curses.curs_set(1)
        try:
            raw = stdscr.getstr(y, x, max(1, w - x - 1))
        finally:
            curses.noecho()
            curses.curs_set(0)
        try:
            return raw.decode("utf-8")
        except Exception:
            return None

    def show_text_panel(title_text: str, content: str) -> None:
        lines = content.splitlines() or [""]
        h, w = stdscr.getmaxyx()
        top = 2
        left = 2
        panel_w = max(20, min(w - 4, max((len(l) for l in lines), default=0) + 4))
        panel_h = max(6, min(h - 4, len(lines) + 4))
        stdscr.clear()
        stdscr.addstr(top, left, "+" + "-" * (panel_w - 2) + "+", c_header)
        stdscr.addstr(top + 1, left, "|" + " " * (panel_w - 2) + "|", c_header)
        stdscr.addstr(top + 1, left + 2, clip_text(title_text, panel_w - 4), curses.A_BOLD)
        for i in range(panel_h - 4):
            stdscr.addstr(top + 2 + i, left, "|" + " " * (panel_w - 2) + "|", c_header)
            if i < len(lines):
                stdscr.addstr(top + 2 + i, left + 2, clip_text(lines[i], panel_w - 4))
        stdscr.addstr(top + panel_h - 2, left, "|" + " " * (panel_w - 2) + "|", c_header)
        hint = "Press any key to return"
        stdscr.addstr(top + panel_h - 2, left + 2, clip_text(hint, panel_w - 4), c_inactive)
        stdscr.addstr(top + panel_h - 1, left, "+" + "-" * (panel_w - 2) + "+", c_header)
        stdscr.refresh()
        stdscr.getch()

    def detail_view(selected_name: str) -> str:
        local_msg = "q back | e edit exec | c edit schedule | r recreate | x exec | s/t/R actions"
        while True:
            current = get_managed(selected_name)
            if not current:
                return "Service removed from registry."
            h, w = stdscr.getmaxyx()
            s_state = unit_active(f"{selected_name}.service") if unit_exists(f"{selected_name}.service") else "missing"
            t_state = unit_active(f"{selected_name}.timer") if unit_exists(f"{selected_name}.timer") else "n/a"
            gpu_memory_by_pid = read_gpu_memory_by_pid()
            usage = read_unit_usage(selected_name, gpu_memory_by_pid)
            schedule = schedule_for_display(current) or "-"

            stdscr.clear()
            stdscr.addstr(0, 0, " " * max(0, w - 1), curses.A_REVERSE)
            title_line = f" Service #{current.id}: {current.name} "
            stdscr.addstr(0, 1, clip_text(title_line, max(0, w - 2)), curses.A_REVERSE | curses.A_BOLD)
            stdscr.addstr(1, 1, clip_text(local_msg, max(0, w - 2)))

            y = 3
            rows = [
                ("status", s_state),
                ("timer", t_state),
                ("schedule", schedule),
                ("cpu", usage["cpu"]),
                ("memory", usage["memory"]),
                ("gpu memory", usage["gpu"]),
                ("restart", current.restart),
                ("working_dir", current.working_dir or "-"),
                ("user", current.user or "-"),
                ("description", current.description),
                ("exec", current.exec_cmd),
            ]
            for label, value in rows:
                if y >= h - 2:
                    break
                stdscr.addstr(y, 2, f"{label:12}", c_header | curses.A_BOLD)
                stdscr.addstr(y, 16, clip_text(value, max(0, w - 18)))
                y += 1

            stdscr.refresh()
            ch = stdscr.getch()
            if ch in (ord("q"), 27):
                return "Back to list."
            if ch == ord("r"):
                show_text_panel("recreate", build_recreate_command(current))
            elif ch == ord("x"):
                run_sudo(["systemctl", "start", f"{selected_name}.service"], check=False)
                local_msg = f"exec -> {selected_name}.service"
            elif ch == ord("s"):
                apply_action_for_managed(current, "start")
                target = "timer" if managed_uses_timer(current) else "service"
                local_msg = f"start -> {selected_name}.{target}"
            elif ch == ord("t"):
                apply_action_for_managed(current, "stop")
                target = "timer" if managed_uses_timer(current) else "service"
                local_msg = f"stop -> {selected_name}.{target}"
            elif ch == ord("R"):
                apply_action_for_managed(current, "restart")
                target = "timer" if managed_uses_timer(current) else "service"
                local_msg = f"restart -> {selected_name}.{target}"
            elif ch == ord("e"):
                value = prompt_input("New exec (blank keeps current):")
                if value is not None and value.strip():
                    if apply_managed_update(current, exec_cmd=value.strip()):
                        sync_registry_from_systemd(selected_name)
                        local_msg = "Exec updated."
                    else:
                        local_msg = "No changes applied."
            elif ch == ord("c"):
                value = prompt_input("New schedule (blank clears timer):")
                if value is not None:
                    v = value.strip()
                    changed = apply_managed_update(
                        current,
                        schedule=v if v else "",
                        clear_schedule=(v == ""),
                    )
                    sync_registry_from_systemd(selected_name)
                    local_msg = "Schedule updated." if changed else "No changes applied."

    while True:
        services = sorted(load_registry(), key=lambda s: s.name.lower())
        if services:
            idx = max(0, min(idx, len(services) - 1))
        else:
            idx = 0
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # Top bar
        title = " Skuld TUI "
        stdscr.addstr(0, 0, " " * max(0, width - 1), curses.A_REVERSE)
        stdscr.addstr(0, 1, title[: max(0, width - 2)], curses.A_REVERSE | curses.A_BOLD)
        stdscr.addstr(1, 1, clip_text(message, max(0, width - 2)))

        start_y = 3
        border = hline()
        header = row_line([name for name, _ in columns])
        if len(border) > width - 1:
            stdscr.addstr(start_y, 0, "Terminal too narrow for table view.")
            stdscr.refresh()
            ch = stdscr.getch()
            if ch in (ord("q"), 27):
                return
            continue

        stdscr.addstr(start_y, 0, border, c_header)
        stdscr.addstr(start_y + 1, 0, header, curses.A_BOLD | c_header)
        stdscr.addstr(start_y + 2, 0, border, c_header)

        max_rows = max(0, height - (start_y + 5))
        visible = services[:max_rows]
        gpu_memory_by_pid = read_gpu_memory_by_pid()
        for i, svc in enumerate(visible):
            service_state = unit_active(f"{svc.name}.service") if unit_exists(f"{svc.name}.service") else "missing"
            timer_state = unit_active(f"{svc.name}.timer") if unit_exists(f"{svc.name}.timer") else "n/a"
            sched = schedule_for_display(svc) or "-"
            usage = read_unit_usage(svc.name, gpu_memory_by_pid)
            kind = "timer" if sched != "-" else "daemon"

            line = row_line(
                [
                    str(svc.id),
                    svc.name,
                    kind,
                    service_state,
                    timer_state,
                    sched,
                    usage["cpu"],
                    usage["memory"],
                    usage["gpu"],
                    read_unit_ports(svc.name),
                ]
            )
            row_y = start_y + 3 + i
            row_attr = curses.A_REVERSE if i == idx else curses.A_NORMAL
            stdscr.addstr(row_y, 0, line, row_attr)

            # Colorize service status text in-place (if color support exists).
            status_x = 0
            for name, w in columns[:3]:
                status_x += w + 3
            status_x += 2
            status_attr = c_missing
            if service_state == "active":
                status_attr = c_active
            elif service_state == "inactive":
                status_attr = c_inactive
            stdscr.addstr(row_y, status_x, clip_text(service_state, columns[3][1]), row_attr | status_attr | curses.A_BOLD)

            # Colorize timer status text in-place.
            timer_x = status_x + columns[3][1] + 3
            timer_attr = c_missing
            if timer_state == "active":
                timer_attr = c_active
            elif timer_state == "inactive":
                timer_attr = c_inactive
            elif timer_state == "n/a":
                timer_attr = c_na
            stdscr.addstr(row_y, timer_x, clip_text(timer_state, columns[4][1]), row_attr | timer_attr | curses.A_BOLD)

        footer_y = start_y + 3 + len(visible)
        if footer_y < height:
            stdscr.addstr(footer_y, 0, border, c_header)

        if not services and (footer_y + 1) < height:
            stdscr.addstr(footer_y + 1, 1, "No registered services. Use: skuld create ...")

        stdscr.refresh()
        ch = stdscr.getch()

        if ch in (ord("q"), 27):
            return
        if ch in (curses.KEY_DOWN, ord("j")) and services:
            idx = min(idx + 1, len(services) - 1)
        elif ch in (curses.KEY_UP, ord("k")) and services:
            idx = max(idx - 1, 0)
        elif ch == ord("r"):
            message = "Refreshed"
        elif ch in (ord("\n"), 10, 13) and services:
            selected = services[idx]
            message = detail_view(selected.name)
        elif ch in (ord("e"), ord("s"), ord("t"), ord("R"), ord("d")) and services:
            selected = services[idx]
            if ch == ord("e"):
                run_sudo(["systemctl", "start", f"{selected.name}.service"], check=False)
                message = f"exec -> {selected.name}.service"
            elif ch == ord("s"):
                apply_action_for_managed(selected, "start")
                target = "timer" if managed_uses_timer(selected) else "service"
                message = f"start -> {selected.name}.{target}"
            elif ch == ord("t"):
                apply_action_for_managed(selected, "stop")
                target = "timer" if managed_uses_timer(selected) else "service"
                message = f"stop -> {selected.name}.{target}"
            elif ch == ord("R"):
                apply_action_for_managed(selected, "restart")
                target = "timer" if managed_uses_timer(selected) else "service"
                message = f"restart -> {selected.name}.{target}"
            elif ch == ord("d"):
                desc = get_managed(selected.name)
                if desc:
                    message = f"{selected.name}: {desc.description}"


def tui(_args: argparse.Namespace) -> None:
    require_systemctl()
    sync_registry_from_systemd()
    curses.wrapper(tui_loop)


def sync(args: argparse.Namespace) -> None:
    svc = resolve_managed_arg(args, required=False)
    name = svc.name if svc else None
    require_systemctl()
    changed = sync_registry_from_systemd(name)
    if changed == 0:
        ok("Registry is already up to date.")
    else:
        ok(f"Registry updated for {changed} service(s).")


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="skuld", description="CLI/TUI for managing systemd services")
    p.add_argument(
        "--no-env-sudo",
        action="store_true",
        help="Disable SKULD_SUDO_PASSWORD from env/.env and use regular sudo behavior",
    )
    sub = p.add_subparsers(dest="command", required=False)

    c = sub.add_parser("create", help="Create and install .service and optional .timer")
    c.add_argument("--name", required=True)
    c.add_argument("--exec", required=True, help="ExecStart command")
    c.add_argument("--description")
    c.add_argument("--working-dir")
    c.add_argument("--user")
    c.add_argument("--restart", default="on-failure")
    c.add_argument("--schedule", help="Timer OnCalendar expression")
    c.add_argument("--timer-persistent", action=argparse.BooleanOptionalAction, default=True)
    c.set_defaults(func=create)

    l = sub.add_parser("list", help="List services managed by skuld")
    l.set_defaults(func=list_services)

    e = sub.add_parser("exec", help="Execute a service immediately")
    e.add_argument("name", nargs="?")
    e.add_argument("--name", dest="name_flag")
    e.add_argument("--id", dest="id_flag", type=int)
    e.set_defaults(func=exec_now)

    s = sub.add_parser("start", help="Start one or more services")
    s.add_argument("targets", nargs="*", help="Service target(s): managed NAME and/or ID")
    s.add_argument("--name", dest="name_flag")
    s.add_argument("--id", dest="id_flag", type=int)
    s.set_defaults(func=lambda a: start_stop(a, "start"))

    st = sub.add_parser("stop", help="Stop one or more services")
    st.add_argument("targets", nargs="*", help="Service target(s): managed NAME and/or ID")
    st.add_argument("--name", dest="name_flag")
    st.add_argument("--id", dest="id_flag", type=int)
    st.set_defaults(func=lambda a: start_stop(a, "stop"))

    rs = sub.add_parser("restart", help="Restart one or more services")
    rs.add_argument("targets", nargs="*", help="Service target(s): managed NAME and/or ID")
    rs.add_argument("--name", dest="name_flag")
    rs.add_argument("--id", dest="id_flag", type=int)
    rs.set_defaults(func=restart)

    ps = sub.add_parser("status", help="Service/timer status")
    ps.add_argument("name", nargs="?")
    ps.add_argument("--name", dest="name_flag")
    ps.add_argument("--id", dest="id_flag", type=int)
    ps.set_defaults(func=status)

    lg = sub.add_parser("logs", help="Show logs from journalctl")
    lg.add_argument("name", nargs="?")
    lg.add_argument("lines_pos", nargs="?", type=int)
    lg.add_argument("--name", dest="name_flag")
    lg.add_argument("--id", dest="id_flag", type=int)
    lg.add_argument("--lines", type=int, default=None)
    lg.add_argument("--follow", action="store_true", help="Follow logs in real time")
    lg.add_argument("--folow", dest="follow", action="store_true", help=argparse.SUPPRESS)
    lg.add_argument("--since", help="journalctl time filter (example: '1 hour ago')")
    lg.add_argument("--timer", action="store_true", help="Read .timer logs instead of .service")
    lg.add_argument("--output", default="short", help="journalctl output mode (e.g. short, short-iso, cat, json)")
    lg.add_argument("--plain", action="store_true", help="Shortcut for --output cat (message only)")
    lg.set_defaults(func=logs)

    rm = sub.add_parser("remove", help="Remove units")
    rm.add_argument("name", nargs="?")
    rm.add_argument("--name", dest="name_flag")
    rm.add_argument("--id", dest="id_flag", type=int)
    rm.add_argument("--purge", action="store_true")
    rm.set_defaults(func=remove)

    ad = sub.add_parser("adopt", help="Adopt an existing systemd service into skuld registry")
    ad.add_argument("name", nargs="?")
    ad.add_argument("--name", dest="name_flag")
    ad.set_defaults(func=adopt)

    dr = sub.add_parser("doctor", help="Check registry/systemd inconsistencies")
    dr.set_defaults(func=doctor)

    ed = sub.add_parser("edit", help="Edit a managed service definition")
    ed.add_argument("name", nargs="?")
    ed.add_argument("--name", dest="name_flag")
    ed.add_argument("--id", dest="id_flag", type=int)
    ed.add_argument("--exec")
    ed.add_argument("--description")
    ed.add_argument("--working-dir")
    ed.add_argument("--user")
    ed.add_argument("--restart")
    ed.add_argument("--schedule")
    ed.add_argument("--clear-schedule", action="store_true")
    ed.add_argument("--timer-persistent", action=argparse.BooleanOptionalAction, default=None)
    ed.set_defaults(func=edit)

    ds = sub.add_parser("describe", help="Show details for a managed service")
    ds.add_argument("name", nargs="?")
    ds.add_argument("--name", dest="name_flag")
    ds.add_argument("--id", dest="id_flag", type=int)
    ds.set_defaults(func=describe)

    rc = sub.add_parser("recreate", help="Print equivalent skuld create command for a managed service")
    rc.add_argument("name", nargs="?")
    rc.add_argument("--name", dest="name_flag")
    rc.add_argument("--id", dest="id_flag", type=int)
    rc.set_defaults(func=recreate)

    sy = sub.add_parser("sync", help="Backfill missing registry fields from systemd")
    sy.add_argument("name", nargs="?", help="Sync only one managed service")
    sy.add_argument("--name", dest="name_flag", help="Sync only one managed service")
    sy.add_argument("--id", dest="id_flag", type=int, help="Sync only one managed service by id")
    sy.set_defaults(func=sync)

    t = sub.add_parser("tui", help="Open terminal UI")
    t.set_defaults(func=tui)

    v = sub.add_parser("version", help="Show version")
    v.set_defaults(func=lambda _a: print(VERSION))

    return p


def main() -> int:
    global USE_ENV_SUDO
    parser = build_parser()
    args = parser.parse_args()
    USE_ENV_SUDO = not args.no_env_sudo
    try:
        if not getattr(args, "command", None):
            list_services(argparse.Namespace())
            print("Quick help: skuld <id|name> commands: exec/start/stop/restart/status/logs/describe/edit/remove")
            print()
            return 0

        args.func(args)
        if args.command in {"create", "exec", "start", "stop", "restart", "remove", "adopt", "edit", "sync"}:
            print()
            list_services(argparse.Namespace())
        return 0
    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        err(str(exc))
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
